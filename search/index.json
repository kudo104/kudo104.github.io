[{"content":"Overview We can see that this is a C# file, using .NET Reactor for obfuscation to avoid analysis and detection by antivirus software.\nUnpack I used .NETReactorSlayer to unpack, and you can see the difference before and after unpacking.\nAnalysis Stolen The malware captures the username and password at owa/auth when login on Mail Exchange. The credentials are stored in C:\\windows\\temp~ex.dat, XORed with 183, and then saved in base64 format.\n~ex.dat file of the malware stores the following information:\nTimestamp Remote IP address Username and Password upon login 1 9/6/2024 3:39:01 PM\t192.168.204.166\tusername pasword\tMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36\t302 Connect Attacker uses a special sessionid field to connect to the server, allowing them to execute commands and download anything.\nIOCs MD5: A13E534F18967AF816FBE0EF83CC2AB8\nFile: ~ex.dat\n","date":"2024-06-11T00:00:00Z","image":"https://kudo104.github.io/p/owabackdoor_eng/image_hu14548736469287068175.png","permalink":"https://kudo104.github.io/p/owabackdoor_eng/","title":"Owa Bakcdoor on Microsoft Exchange"},{"content":"Tổng quan Ta có thể nhìn thấy thì đây là một file C#, sử dụng .NET Reactor để obfuscation tránh việc phân tích và phát hiện của AV.\nUnpack Mình sử dụng .NETReactorSlayer để unpack các bạn có thể thấy sự khác biệt trước và sau khi unpack\nPhân tích stolen Mã độc thực hiện lấy username password tại owa/auth.owa khi thực hiện đăng nhập trên Mail exchange. Credential được lưu ở C:\\windows\\temp\\~ex.dat, xor 183 và sau đó sẽ thực hiện lưu dưới dạng base64\nFile ~ex.dat của mã độc lưu các thông tin như sau:\nThời gian Remote ip address Username và Password khi login 1 9/6/2024 3:39:01 PM\t192.168.204.166\tusername pasword\tMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36\t302 Kết nối Kẻ tấn công sử dụng trường sessionid dùng để connect đến server có thể thực thi command, download bất kì\nIOCs MD5: A13E534F18967AF816FBE0EF83CC2AB8\nFile: ~ex.dat\n","date":"2024-06-11T00:00:00Z","image":"https://kudo104.github.io/p/owabackdoorvn/image_hu14548736469287068175.png","permalink":"https://kudo104.github.io/p/owabackdoorvn/","title":"Owa Bakcdoor trong Microsoft Exchange"},{"content":"Để debug kernel chúng ta cần 1 máy ảo và 1 máy host để debug. Máy host để debug cần cài Windbg để thực hiện debug\nMáy ảo - 192.168.1.6 Máy ảo mình sử dụng Windows 10\nViệc đầu tiên chúng ta cần làm trên máy ảo để debug là tắt năng check signature của windows để load kernel\n1 2 3 bcdedit /set nointegritychecks on bcdedit /set testsigning on Tiếp theo thực hiện các câu lệnh sau để enbale debug. Windbg hổ trợ nhiều loại debug khác nhau như Net, COM,.. Ở đây mình setup debug thông qua Net\n1 2 3 bcdedit /debug on bcdedit /dbgsettings net hostip:ip_vmware port:port_des bcdedit /set testsigning on Tiếp theo thực hiện câu lệnh sau để lưu thông tin như key, hostip, port để debug\nMáy host Sử dụng key, port đã lưu ở trên nhập các thông tin trong windbg\nLoad debug thành công\nSau khi load debug thành công trên windbg tiếp tục settup trên IDA\nChọn Windbg debuger:\nTrên thanh menu Debugger-\u0026gt;Debug option-\u0026gt; Set specific option -\u0026gt; chọn kernel mode debugging\nChọn Debugger-\u0026gt;Process option tại Connection string điền theo format sau: Net:port=\u0026lt;….\u0026gt;,key=\u0026lt;….\u0026gt;\nnet:port=53000,key=3iexu1qpvssyt.1y5lv21youkjd.l10jice73w0c.3jsz76o1ni538 -\u0026gt; OK\nBây giờ chúng ta chạy và debug thôi ^.^. Đi pha tách coffe ngồi đợi thôi. Nếu mà có hình Refreshing module list thì debug thành công đợi nó tải hoàn tất các symbol.\nDebug thành công\nLưu ý: Nếu không hiển thị Refreshing module list thì từ câu lệnh nàybcdedit /dbgsettings net hostip:ip_vmware port:port_des ta đổi thành .\\kdnet.exe ip_host port_des file kdnet.exe tại dường dẫn C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64 trên máy machine.\n","date":"2023-04-11T00:00:00Z","image":"https://kudo104.github.io/p/debugkernel/images_hu8250063957579694982.jpg","permalink":"https://kudo104.github.io/p/debugkernel/","title":"How to debug kernel in windows"},{"content":"Frida Frida is a dynamic instrumentation tool that allows developers and security researchers to inject JavaScript into running processes on mobile and desktop platforms.\nHooking a funtion at VA when you read this article,i suggest that you should consider reading this article first here.\nIn the program,there are many funtions we want to hook.How we can find addresses to hook.\nYou can based on offset after decompile to hooking funtions not defined in GCC,MSVC,..\nExample from Line CTF 2023 finish.exe. I want to hook the list of functions below to trace the flow of the program.\nYou can see table of funtions in IDA.Colum start is the address of function such as 140001DDB,140001AE6,\u0026hellip;\nMy script frida hook.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import frida import sys # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa session = frida.attach(\u0026#34;fishing.exe\u0026#34;) script = session.create_script(\u0026#34;\u0026#34;\u0026#34; Interceptor.attach(ptr(\u0026#34;0x7ff67a022310\u0026#34;), { onEnter(args) { console.log(\u0026#34;cal rc4\u0026#34; + args[0].toInt32()); } }); Interceptor.attach(ptr(\u0026#34;0x7ff67a0217D0\u0026#34;), { onEnter(args) { console.log(\u0026#34;call Handle :\u0026#34; + args[0].toInt32()); } }); Interceptor.attach(ptr(\u0026#34;0x7ff67a021CDF\u0026#34;), { onEnter(args) { console.log(\u0026#34;call xor 21 :\u0026#34; + args[0].toInt32()); } }); Interceptor.attach(ptr(\u0026#34;0x7ff67a021D33\u0026#34;), { onEnter(args) { console.log(\u0026#34;call sub 34 :\u0026#34; + args[0].toInt32()); } }); Interceptor.attach(ptr(\u0026#34;0x7ff67a021D87\u0026#34;), { onEnter(args) { console.log(\u0026#34;call xor 11 :\u0026#34; + args[0].toInt32()); } }); Interceptor.attach(ptr(\u0026#34;0x7ff67a021DDB\u0026#34;), { onEnter(args) { console.log(\u0026#34;call add 18 :\u0026#34; + args[0].toInt32()); } }); \u0026#34;\u0026#34;\u0026#34;) def on_message(message, data): print(message) script.on(\u0026#39;message\u0026#39;, on_message) script.load() sys.stdin.read() when program loading into process.Windows Loader relies on the PE file structure to load it into the memory.\nWindow Load will mapped relies on ImagBase of Nt HEARDER sometimes that memory is used windows loader will choose another imagebase to load the program into the memory process\nYou can use Process Explorer to see where the program is loaded into memory to fine-tune the position of the functions you want to hook.\nYou can see that the \u0026lsquo;LoadAddress\u0026rsquo; is 0x7ff6a4b10000, which we need to know in order to fix the script.\nHook is successful, and now we know the flow of the program and how it works.\nFlag LINECTF{e255cda25f1a8a634b31458d2ec405b6}\nResources https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/instrumenting-windows-apis-with-frida\nhttps://fuzzysecurity.com/tutorials/29.html\nhttps://frida.re/docs/functions/\n","date":"2023-04-03T00:00:00Z","image":"https://kudo104.github.io/p/frida/cover_hu16953855724371392771.png","permalink":"https://kudo104.github.io/p/frida/","title":"Hooking Windows API with frida"},{"content":"Cobalt Strike được biết đến là framework mô phỏng tấn công với nhiều mô đun và tính năng. Do tính linh hoạt, Cobalt Strike trở nên phổ biến với redteam, cũng như được sử dụng nhiều bởi các nhóm tấn công mạng.\nSau quá trình phân tích một số mẫu, chúng tôi ghi nhận nhiều mẫu mã độc được drop xuống máy nạn nhân nhằm triển khai các beacon Cobalt Strike. Đặc điểm chung là đều thực thi các beacon này trong memory nhằm lẩn tránh sự phát hiện của các tiến trình Antivirus.\nSơ đồ hoạt động:\nQuá trình xử lý sự cố chúng tôi thu thập được mẫu mã độc có tên cdpsgshims.dll tại thư mục C:\\Windows\\System32, rà soát cùng thư mục cũng phát hiện file MapData.dat có ngày và thời gian tạo tương đồng với file cdpsgshims.dll (Ngoài ra cũng phát hiện file này tại đường dẫn C:\\ProgramData\\Microsoft\\MapDat, đây là file cấu hình được sử dụng để DLL gọi tới về sau)\nPhân tích cdpsgshims.dll File DLL này là PE file 64 bit, có tên gốc là TSVIPSrv.dll. Export một số function, đáng chú ý là function là OfficeClickToRun\nLoad DLL và phân tích với IDA, quan sát code tại một số hàm thì nhận thấy một số strings đã bị obfuscated, các chuỗi có thể được giải mã bằng cách xor lần với các giá trị 0x4b,0x43,0x51 (KCQ trong bảng mã ASCII)\nSau khi giải mã thu được thì được một số strings, trong đó có một số strings có nội dung đặc biệt như CreateRemoteThread và đường dẫn C:\\\\\\\\ProgramData\\\\\\\\Microsoft\\\\\\\\MapData\\\\\\MapData.dat\nKhi DLL được load, DLL entrypoint sẽ gọi tới hàm export function OfficeClickToRun. Hàm này thực hiện nhiệm vụ cấu thành đường dẫn tới file MapData.dat tại đường dẫn C:\\\\\\\\ProgramData\\\\\\\\Microsoft\\\\\\\\MapData\\\\\\MapData.dat và đọc nội dung file MapData.dat\nSau khi đọc file, thực hiện giải mã bằng thuật toán với key là SYSTEM. Sau khi giải mã thành công, payload mới sẽ được gọi sẽ được thực thi\nPayload mới là CobaltStrike Beacon HTTPS, đến đây có có thể trích xuất được thông tin cấu hình bằng công cụ CobaltStrikeParser của Sentinel-One hoặc 1768.py của Didier Stevens\nKhôi phục Import Table Một cách thủ công khác, sau quá trình giải mã RC4, chúng ta có thể thực hiện dump payload mới xuống. Nếu load thử bằng CFF Explorer sẽ không nhận diện được đây là PE file. Lý do là file đã đổi signature MZ và PE thành YA và IY\nCó thể sửa lại các giá trị trong file từ ‘YA’ thành ‘MZ’ và ‘IY’ thành ‘PE’ bằng các công cụ như HxD hay 010 Editor. Tuy nhiên các thông tin import và các session hầu như đều không còn được nguyên vẹn.\nLoad file dump.dll vào IDA để phân tích, sau khi giải mã RC4 ở trên hàm export function v3.28 sẽ được gọi tới và thực thi, gần giống với kĩ thuật ReflectiveLoad.\nMột chỗ cần lưu ý trong hàm này là nó đọc giá trị NumberOfSybols từ File Header và lưu vào biến key sau đó biến này được sử dụng trong hàm DecryptString.Hàm này có chức năng giải mã các string bảng import table hay là tên các section.\nHàm export function v3.28 này có nhiệm vụ: Tìm data PE file trong dll để load vào vùng nhớ process Tìm các Module để load các API Giải mã các string trong import table để mapped địa chỉ vào vùng nhớ process Cuối cùng là thực thi Dll tại DllEntryPoint Dựa vào các thông tin trên,có thể khôi phục lại bảng import table.Đây là script để khôi phục lại IAT:\nKết quả sau quá trình khôi phục như sau:\nIndicators of Compromises (IOCs) File name:\ncdpsgshims.dll 283A861CD7E1D26325DE39478B305432 (MD5)\npython23.dll 53F030E658E7D95A2DBB5AC9B99176B6 (MD5)\nTmDbgLog.dll 9B12F3471260840953025F2C39B47DCC (MD5)\nFile config:\nMapData.dat 6F5A07D59D8B637E38DCA7A1575CD229 (MD5)\nwinnt.config DD4E176F33F91E27F557A4D67F9B3331 (MD5)\nmtxstify.scr EE4B2DA99308C3E7EA81C4E1F80C946E (MD5)\nC2:\ndidongbuy.com\nnews.worldstockhub.com\n18.138.81.223\n","date":"2022-12-28T00:00:00Z","image":"https://kudo104.github.io/p/cobaltstrike/CobaltStrike_hu10163292240895949457.jpg","permalink":"https://kudo104.github.io/p/cobaltstrike/","title":"Cobalt Strike"},{"content":"Tác giả cho 2 file ctf_challenge và output.txt.Đây là một dạng bài phục hồi lại nội dung trong file.\nBỏ vào ida thì biết được chương trình đọc nội dung flag.txt để encrypt\nTạo file flag.txt và thử thêm nôi dụng là ASCIS{aaaaaaaaa} để chạy file. Hmm nhìn khá là ảo thử lấy đống hex này sang string thử ,chương trình lại cho ra đúng nội dung của flag.\nTiếp tục re tiếp thì bài này là một dạng vm mình sẽ không nói chi tiết mấy cái này tại thấy dài dòng quá.Bài này cấp phát một vùng nhớ 50 byte có quyền thực thi và set cái tất cả các byte trong vùng nhớ thành 0x90 đây chính là lệnh nop và thêm 2 byte \\xEB\\xFE này vào vùng nhớ gần cuối đây chính là lệnh jump nhảy tới chính nó đó.Sau đó nó sẽ tạo Thread thực thi vòng lặp vô tận đợi đến khi mà chương trình gọi SuspendThread để tạm dừng Thread lại.Sau đó chương trình sẽ tính toán và sẽ thực thi từng câu lệnh một trong vùng nhớ này.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 char *__thiscall sub_321040(char *this, _OWORD *a2) { LPVOID v3; // eax _OWORD *v4; // ecx char *v5; // ecx int v6; // eax int v7; // ecx int v8; // eax void *v10; // [esp-10h] [ebp-1Ch] void *v11; // [esp-Ch] [ebp-18h] LPTHREAD_START_ROUTINE lpStartAddress; // [esp+8h] [ebp-4h] *this = \u0026amp;VM::`vftable\u0026#39;; *(this + 2) = this; *(this + 12) = 0i64; *(this + 28) = 0i64; *(this + 11) = 0; lpStartAddress = VirtualAlloc(0, 0x50u, 0x3000u, 0x40u); *(this + 16) = VirtualAlloc(0, 0x40u, 0x1000u, 0x40u); *(this + 14) = VirtualAlloc(0, 0x40u, 0x3000u, 4u); v3 = VirtualAlloc(0, 0xC8u, 0x3000u, 4u); v10 = *(this + 14); *(this + 17) = v3; memset(v10, 0, 0x40u); memset(*(this + 17), 0, 0x40u); memset(*(this + 16), 0, 0x200u); memset(lpStartAddress, 144, 0x50u); v4 = *(this + 14); if ( v4 ) { if ( a2 ) { *v4 = *a2; v4[1] = a2[1]; v4[2] = a2[2]; v4[3] = a2[3]; goto LABEL_6; } memset(v4, 0, 0x40u); } *errno() = 22; invalid_parameter_noinfo(); LABEL_6: v5 = *(this + 17); if ( v5 ) { strcpy(v5, \u0026#34;1234567890123456\u0026#34;); } else { *errno() = 22; invalid_parameter_noinfo(); } *(this + 15) = lpStartAddress; *(lpStartAddress + 72) = \u0026#39;\\xEB\u0026#39;; *(*(this + 15) + 73) = \u0026#39;\\xFE\u0026#39;; *(this + 376) = CreateThread(0, 0, lpStartAddress, 0, 0, 0); Sleep(0x3E8u); SuspendThread(*(this + 376)); *(this + 197) = 65599; GetThreadContext(*(this + 376), (this + 788)); *(this + 237) = *(this + 17); *(this + 236) = *(this + 14); v6 = *(this + 16); v11 = *(this + 376); *(this + 241) = 0; v7 = v6 + 384; *(this + 238) = 0; v6 += 32; *(this + 240) = 0; *(this + 13) = v6; *(this + 246) = v6; v8 = *(this + 15); *(this + 239) = 0; *(this + 12) = v7; *(this + 242) = v7; *(this + 243) = v8; SetThreadContext(v11, (this + 788)); return this; } Đáng chú ý trong quá trình debug thì mình bị lỗi segment liên tục thì phát hiện có 1 anti hardware breapoint\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 BOOL __thiscall sub_E1930(int *this) { void *v3; // [esp-Ch] [ebp-14h] void *v4; // [esp-8h] [ebp-10h] SuspendThread(this[376]); GetThreadContext(this[376], (this + 197)); v3 = this[15]; this[243] = v3; memset(v3, 0x90, 0x50u); *(this[15] + 72) = -21; *(this[15] + 73) = -2; if ( this[198] || this[199] || this[200] || this[201] ) { *(this[15] + 72) = 0x90; *(this[15] + 73) = 0x90; } v4 = this[376]; this[198] = 0; this[199] = 0; this[200] = 0; this[201] = 0; this[202] = 0; this[203] = 0; return SetThreadContext(v4, (this + 197)); } Đến đây mình patch lại chương trình tưởng có thể chạy ngon lành cành đào rồi nhưng không nó lại in ra đúng nối dung của file flag.txt.Mình thử debug tới câu lệnh cuối cùng trong vùng nhớ rồi in ra thì biết được nó tính độ dài của chuỗi và so sánh với 0x24.Hmm chạy ngon rồi haha.\nMình patch lại như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 BOOL __thiscall sub_321930(int *this) { void *v3; // [esp-Ch] [ebp-14h] void *v4; // [esp-8h] [ebp-10h] SuspendThread(this[376]); GetThreadContext(this[376], (this + 197)); v3 = this[15]; this[243] = v3; memset(v3, 144, 0x50u); *(this[15] + 72) = \u0026#39;\\xEB\u0026#39;; *(this[15] + 73) = \u0026#39;\\xFE\u0026#39;; v4 = this[376]; this[198] = 0; this[199] = 0; this[200] = 0; this[201] = 0; this[202] = 0; this[203] = 0; return SetThreadContext(v4, (this + 197)); } Mình sử dụng mấy câu lẹnh debug_hook của ida không chạy được nên đành chạy tay lấy từng câu lệnh một click đến khi nào chương trình dừng thì thôi do mình lười emulate lại cái code vm :vv\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import idaapi import time f = open(\u0026#34;log.txt\u0026#34;,\u0026#34;a\u0026#34;) idaapi.run_to(0xB81F93) data = [] # ea là địa chỉ vùng nhớ được cấp phát 50 byte để thực thi câu lệnh for ea in range(0x950000,0x950006,1): data.append(idc.get_wide_byte(ea)) s = \u0026#39; \u0026#39;.join([str(elem) for elem in data]) s += \u0026#34;\\n\u0026#34; f.write(s) f.close() Sau khi đọc mấy cái code vm này thì biết được đây là mã hóa XTEA.Đoạn Vm sử dụng Xtea 4 lần mỗi lần là 8 byte ban đầu key là 1234567890123456 sau đó nó sẽ thực hiện thay đổi key lần lược như sau xor 4 byte với 0xefbeadde và đặt tại 4 byte tiếp theo.\n1 2 3 4 5 6 7 8 9 10 0: 89 78 04 mov DWORD PTR [eax+0x4], edi 0: 8b 1c 24 mov ebx, DWORD PTR [esp] 0: 8b 74 24 04 mov esi, DWORD PTR [esp+0x4] 0: 8b 7c 24 08 mov edi, DWORD PTR [esp+0x8] 0: 8b 56 04 mov edx, DWORD PTR [esi+0x4] 0: bb de ad be ef mov ebx, 0xefbeadde 0: 31 da xor edx, ebx 0: 89 56 08 mov DWORD PTR [esi+0x8], edx 0: 81 c7 08 00 00 00 add edi, 0x8 0: 89 7d 08 mov DWORD PTR [ebp+0x8], edi Đọc các đoạn tiếp theo mình được key và script giải mã flag:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void decrypt (uint32_t v[2], const uint32_t k[4]) { uint32_t v0 = v[0], v1 = v[1], sum = 0xf1bbcdc8, i; /* set up; sum is (delta \u0026lt;\u0026lt; 5) \u0026amp; 0xFFFFFFFF */ uint32_t delta = 0x9E3779B9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i=0; i \u0026lt; 8; i++) { /* basic cycle start */ v1 -= ((v0 \u0026lt;\u0026lt; 4) + k2) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k3); v0 -= ((v1 \u0026lt;\u0026lt; 4) + k0) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k1); sum -= delta; } v[0] = v0; v[1] = v1; for(int i = 0;i \u0026lt; 4 ; i ++){ printf(\u0026#34;%c\u0026#34;,(v0 \u0026gt;\u0026gt; (8*i)) \u0026amp; 0xff); } for(int i = 0;i \u0026lt; 4 ; i ++){ printf(\u0026#34;%c\u0026#34;,(v1 \u0026gt;\u0026gt; (8*i)) \u0026amp; 0xff); } } int main(){ uint32_t key1[4] = {0x34333231,0x38373635, 0x32313039, 0x36353433}; //\tuint32_t hash[8] = {0x32a86394,0xaea320ce, 0x8d1cbc04, 0xb1228e7a, 0x11b1318a,0xb70ad3aa,0xa2708b62,0x820c8b81}; uint32_t hash1[2] = {0x32a86394, 0xaea320ce}; decrypt(hash1,key1); //\tfor(int i =0; i \u0026lt; 4; i++){ //\tuint32_t h[2]; //\th[0] = hash[i * 2]; //\th[1] = hash[i * 2 + 1]; //\tprintf(\u0026#34;%x %x\\n\u0026#34;,h[0],h[1]); //\tdecrypt(h,key); //\t} uint32_t key2[4] = {0x34333231,0xDBFE99B8, 0x32313039, 0x36353433}; uint32_t hash2[2] = {0x8d1cbc04, 0xb1228e7a}; decrypt(hash2,key2); uint32_t key3[4] = {0x34333231,0xDBFE99B8, 0x34403466, 0x36353433}; uint32_t hash3[2] = {0x11b1318a,0xb70ad3aa}; decrypt(hash3,key3); uint32_t key4[4] = {0xDADB5450,0xDBFE99B8, 0x34403466, 0x36353433}; uint32_t hash4[2] = {0xa2708b62,0x820c8b81}; decrypt(hash4,key4); return 0; } Flag: ASCIS{M@sT3r_0f_V1rtu4l_m4Ch1n3}\n","date":"2022-12-05T00:00:00Z","image":"https://kudo104.github.io/p/ctf_challenge/cover_hu14312423717771742977.jpg","permalink":"https://kudo104.github.io/p/ctf_challenge/","title":"ASCIS 2022-CTF CHALLENGE"},{"content":"Lời đầu tiên mình muốn nói đó là cảm ơn mấy anh em trong KCSC đã giúp đỡ mình rất nhiều để mình clear Flare-on 2022 sau nhiều ngày.\nTổng Quan Đầu tiên mình ném vào Detect it easy để có các thông tin cơ bản, chương trình dùng pyinstaller để đóng gói.\nUnpack \u0026amp; Analysis Sử dụng tool có sẵn PyInstaller Extractor để unpack,file cần reverse 11.pyc\nSử dụng decpmpile3 hay uncompyle6 để decompile pyc thành py.\nSau khi decompile thành file py thì chương trình đã bị pyamor\nSau khi chạy file 11.py thì biết cần 1 số thư viện khác thử decompile Crypt.pyc tại vì 11.pyc load thèn này đầu tiên nên mình decompile thèn này,thì thấy thư viện này cũng bị pyamor trong khi python là mã nguồn mở và decompile thì những thèn khác không bị.Do đó Crypt.py đã bị custom.\nThử tạo 1 file rỗng Crypt.py thì biết được nó dùng ARC4.Chỉ cần tạo 1 class ARC4 và in ra là được flag\n1 2 3 4 5 6 class ARC4: def __init__(self, name): self.name = name def encrypt(self,b): print(b) Flag Pyth0n_Prot3ction_tuRn3d_Up_t0_11@flare-on.com\n","date":"2022-11-30T00:00:00Z","image":"https://kudo104.github.io/p/flare-on/cover_hu17304478398143915561.jpg","permalink":"https://kudo104.github.io/p/flare-on/","title":"Flare-on 2022-the challenge that shall not be named"},{"content":"Tổng quan Load File vào detect it easy và CFF explore để có cái nhìn tổng quan về mẫu mã độc sample.exe\nFile 32bit Dung lượng 730kb nhưng import table chỉ sử dụng 1 số api có thể bị packed Phân tích tỉnh và phân tích động Tool sử dụng Ida\nPhân tích file sample.exe Phân tích \u0026amp; rename lại hàm để dễ dàng phân tích: Dữ liệu mã hóa bằng phép xor khá đơn giản sau khi thử giải mã vài byte đầu thì thấy kí hiệu MZ của cấu trúc PE Sử dụng một funtion inject để inject string vào trong câu trúc PE sau khi đã giải mã.Như hình trên thì String “xmr-usa.dwarfpool.com:8050” tại vị trí 74688 inject vào PE_data Xử kí \u0026amp; thực thi PE_data\nHàm sub_13D1350\nCấp phát vùng nhớ có quyền thực thi sau đó copy toán bộ PE data vào trong vùng nhớ:\nHàm sub_13D12C3\nHàm này xử lí tìm kiếm địa chỉ IAT của PE_data và sử dụng hàm loadmodule tương ứng để tìm kiếm các địa chỉ tương ứng với các api trong PE_data việc này giống như ánh xạ vào không gian địa chỉ process bằng thủ công thay vì windowloader sẽ có nhiệm vụ này Thực thi 1 process khác trong sample.exe\nSau khi tìm kiếm các các địa chỉ api trên các module kernel32.dll,user32.dll,…thì nó sẽ thực thi file tại AddressOfEntryPoint dựa trên câu trúc PE file\nĐể tiện lợi cho việc phân tích thì mình sẽ dump dữ liệu ra thì có 2 cách:\nCó thể sử dụng plugin OllDumpEx trong x64dbg để dump Dùng idapython Sau khi dump đặt tên là dump_sample\nPhân tích file dump_sample Sử dụng api CreateDirectoryW để tạo folder “C:\\Users\\user\\AppData\\Local\\hjfdWLFJwt”\nTại folder mới tạo 1 file executable taskman.exe\nHàm registry\nNếu “SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce” đã được tạo thì sẽ thực hiện lấy giá trị tại “ftwdGcTbXm” và ngược lại\nHàm handleProcessx32 Đoạn đầu khá giống với hàm handleProcessx64 việc tạo ra 1 process notepad với cmd =’ -a cryptonight -o stratum+tcp://xmr-usa.dwarfpool.com:8050 -u 4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbS3d2ZdUYfaKLkAbBLe -p x -t 2’\nSau khi hàm này tạo ra process mới thì viết vào vùng nhớ của process đó một cấu trúc PE_data sau đó tiếp tục thực thi process\nDump \u0026amp; phân tích PE_data2\nDetect it easy thì File bị packed bằng upx sau khi unpacked upx như hình bên dưới:\nCác option tìm thấy trong hàm handleArg,argv \u0026amp; agrc chính cmd khi tạo với proccess notepad.exe\n-a Specifiy the algorithm to use: Cryptonight o URL of mining server: stratum+tcp://xmr-usa.dwarfpool.com:8050 -u username for mining server -p password for mining server -t number of miner threads (default: number of processors) Sau khi tra các string option trên google tìm được project (https://github.com/tpruvot/cpuminer-multi) so sánh với Pseudocode trên Ida thì khá giống với project này đây là công cụ sử dụng khai thác crypto\nHàm handleProcessx64 Tạo process notepad.exe với cmd = ‘ -a cryptonight -o stratum+tcp://xmr-usa.dwarfpool.com:8050 -u4JUdGzvrMFDWrUUwY3toJATSeNwjn54LkCnKBPRzDuhzi5vSepHfUckJNxRL2gjkNrSqtCoRUrEDAgRwsQvVCjZbS3d2ZdUYfaKLkAbBLe -p x -t 2\nSau khi tạo process thì dùng api NtWriteVirtualMemory nó tương tự như WriteProcessMemory cũng có cấu trúc PE được viết vào vùng nhớ process\nDump \u0026amp; phân tích processx64\nDetect it easy thì File bị packed bằng upx sau khi unpacked upx như hình bên dưới:\nCác option tìm thấy trong hàm parse_arg,argv \u0026amp; agrc tương tự như handleProcessx32\nTổng kết Mã độc sinh ra proccess notepad nhằm mục đích ẩn đi chương trình khai thác crypto Các kĩ thuật đặc biệt sử dụng Anti-reverse:upx,anti-diassembly,ịnject string Mục đích chính của mã độc thực hiện khai thác crypto ","date":"2022-06-01T00:00:00Z","image":"https://kudo104.github.io/p/malware/cover_hu6307248181568134095.jpg","permalink":"https://kudo104.github.io/p/malware/","title":"SAMPLE ANALYSIS"},{"content":"Phân tích Chạy file Namep.exe\nLoad file vào CFF explorer để biết được file có resource,mình thấy không có định đạng nên chắc đã bị encode.\nLoad file vào IDA.\nSau một lúc phân tích thì biết file này load resource sau đó decode resource và thực thi cái resource.\nViệc decode thực hiện phép xor mặc định với 0x33\nSau khi mình decode resource thì vẫn không biết đây là gì xin hint từ ông anh mới biết đây là một shellcode.\nMình run shellcode thì biết nó load 1 file gì đó dump ra và load vào IDA,thì tìm được block này hehe file cần tìm đây rồi.\nMình trace ngược lên trên thì biết flag có chuỗi con ASCI nếu không có thì in ra thông báo “Noob~” và ngược lại.\nTiếp tục trace lên trên thì flag được decode bằng mã hóa rc4,mình biết được chuỗi đầu ra nhưng không biết key bao nhiêu byte tiếp tục trace thì key được trả về tại hàm sub_100017A0().Sau một lúc phân tích thì key chỉ có 4 byte,vậy bài này mình đã đủ thông tin để brute.\nĐây là code của mình.\nFLAG ASCIS{a_s1mpl3_pr0toco1}\n","date":"2021-08-10T00:00:00Z","image":"https://kudo104.github.io/p/ctf/cover_hu2294063430624834779.jpg","permalink":"https://kudo104.github.io/p/ctf/","title":"Namep"},{"content":"Phân tích Đây là một chall thực hiện hiện encrypt file,file thưc hiên encrypt với 2 tham số là “file key” và không phải key tùy chọn mà là key mặc định.\nLoad vào IDA ta có flow của chương trình.\nMình tìm kiếm chuỗi “wrong key” sau đó trace ngược lên tại hàm sub_55D62DCA75AE() debug thì biết nó thực hiện so sánh 2 chuỗi số nếu đúng thì bắt đầu encrypt file còn không thì hiện lên màn hình “wrong key” như hình bên trên.\nTiếp tục mình trace theo [rbp+var_240] thì biết input+1483973472739663,sau đó thì tại sub_55D62DCA75AE() so sánh với 4634706992063332.\nHe he vậy key=3150733519323669\nBài này tên crypto nên mình thử dùng plugin fincrypto thì biết thực hiện mã hóa file bằng thuật toán mã hóa AES_ECB\nMình đặt bp tại 0x56438FFF5BBB debug thì được key là P4nd`p\u0026lt;c8gE;T$F8\nVậy bài này mình đã đủ thông tin,để thực giải mã mình sẽ dùng libary của pycryptodome.\nMình load file decrypt vào CFF thì biết đó là 1 file ảnh .png\nFLAG ASCIS{C4yp1o_1s_5impl3_b4t_C++_i5_cr4z9}\n","date":"2021-08-05T00:00:00Z","image":"https://kudo104.github.io/p/ascis/cover_hu14037483057054390636.jpg","permalink":"https://kudo104.github.io/p/ascis/","title":"ASCIS 2020-Crypt"}]